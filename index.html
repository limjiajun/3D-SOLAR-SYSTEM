<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System - Ultimate Control</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        #start-btn {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            padding: 15px 40px; background: #00ffff; color: #000; font-size: 20px; font-weight: bold;
            border: none; border-radius: 30px; cursor: pointer; pointer-events: auto;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            transition: 0.3s;
        }
        #start-btn:hover { background: #fff; box-shadow: 0 0 40px rgba(0, 255, 255, 0.8); }

        .camera-feed {
            position: absolute; bottom: 10px; right: 10px; width: 160px; height: 120px;
            border: 2px solid rgba(0,255,255,0.3); border-radius: 8px;
            transform: scaleX(-1);
            opacity: 0.8; z-index: 20; display: none;
        }

        /* Red cursor only for Hand Tracking */
        #hand-cursor {
            position: absolute; width: 30px; height: 30px;
            background: rgba(255, 0, 0, 0.5);
            border: 2px solid white; border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px red;
            display: none; 
            transition: left 0.05s linear, top 0.05s linear; /* Faster transition */
            pointer-events: none;
        }

        #status {
            position: absolute; top: 20px; left: 20px; color: #00ffff;
            background: rgba(0,0,0,0.7); padding: 10px; border-radius: 8px;
            border-left: 4px solid #00ffff;
            font-size: 14px;
            line-height: 1.5;
        }

        .planet-label {
            color: rgba(255, 255, 255, 0.9);
            font-family: sans-serif;
            font-size: 12px;
            padding: 2px 6px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 4px;
            margin-top: 5px;
            pointer-events: none;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

    <button id="start-btn">Start System</button>
    <div id="ui-layer">
        <div id="status">Waiting for start...</div>
        <div id="hand-cursor"></div>
    </div>
    <video class="camera-feed" playsinline></video>
    <div id="canvas-container"></div>

    <script>
        // === TUNING CONFIGURATION ===
        const CONFIG = {
            edgeThreshold: 0.3,   // 30% of screen edge triggers rotation (Increased from 0.2)
            maxSpeed: 3.0,        // Max rotation speed (Increased significantly)
            smoothing: 0.15       // Smoothing factor for hand cursor
        };

        // 1. Scene Setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.0015);
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
        camera.position.set(0, 60, 120);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const labelRenderer = new THREE.CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        document.getElementById('canvas-container').appendChild(labelRenderer.domElement);

        const mouseControls = new THREE.OrbitControls(camera, renderer.domElement);
        mouseControls.enableDamping = true;
        mouseControls.dampingFactor = 0.05;
        mouseControls.autoRotate = true;
        mouseControls.autoRotateSpeed = 0.5;

        // Lighting
        const sunLight = new THREE.PointLight(0xffaa33, 2, 400);
        scene.add(sunLight);
        scene.add(new THREE.AmbientLight(0x404040));

        // Sun
        const sun = new THREE.Mesh(new THREE.SphereGeometry(8, 64, 64), new THREE.MeshBasicMaterial({ color: 0xffaa00 }));
        scene.add(sun);
        const spriteMat = new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(createGlowTexture()), color: 0xffdd44, transparent: true, blending: THREE.AdditiveBlending });
        const sunGlow = new THREE.Sprite(spriteMat);
        sunGlow.scale.set(40, 40, 1);
        sun.add(sunGlow);

        function createGlowTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const g = ctx.createRadialGradient(64,64,0,64,64,64);
            g.addColorStop(0, 'rgba(255,200,100,1)'); g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = g; ctx.fillRect(0,0,128,128);
            return canvas;
        }

        // Planets
        const planets = [];
        const planetData = [
            { name: "Mercury", r: 0.8, c: 0xAAAAAA, d: 15, s: 0.04 },
            { name: "Venus", r: 1.2, c: 0xD4AF37, d: 22, s: 0.03 },
            { name: "Earth", r: 1.3, c: 0x2233FF, d: 32, s: 0.02 },
            { name: "Mars", r: 1.0, c: 0xFF3300, d: 42, s: 0.015},
            { name: "Jupiter", r: 4.0, c: 0xDDAA77, d: 65, s: 0.008},
            { name: "Saturn", r: 3.5, c: 0xEEDD88, d: 90, s: 0.006}
        ];

        planetData.forEach(p => {
            const mesh = new THREE.Mesh(new THREE.SphereGeometry(p.r, 32, 32), new THREE.MeshPhongMaterial({ color: p.c }));
            const group = new THREE.Object3D();
            group.add(mesh);
            mesh.position.x = p.d;
            
            const track = new THREE.Mesh(new THREE.RingGeometry(p.d-0.1, p.d+0.1, 128), new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.15, transparent: true, side: THREE.DoubleSide }));
            track.rotation.x = -Math.PI/2;
            scene.add(track);
            scene.add(group);

            const div = document.createElement('div');
            div.className = 'planet-label';
            div.textContent = p.name;
            const label = new THREE.CSS2DObject(div);
            label.position.set(0, -p.r - 2, 0); // Label UNDER the planet
            mesh.add(label);

            planets.push({ mesh: mesh, group: group, speed: p.s });
        });

        const starsGeo = new THREE.BufferGeometry();
        const starPos = new Float32Array(2000 * 3);
        for(let i=0; i<6000; i++) starPos[i] = (Math.random()-0.5)*1000;
        starsGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const stars = new THREE.Points(starsGeo, new THREE.PointsMaterial({size: 0.7, color: 0xffffff}));
        scene.add(stars);

        // =========================================
        // 2. UNIFIED INPUT LOGIC (Hand + Mouse)
        // =========================================
        const videoElement = document.querySelector('.camera-feed');
        const cursorDiv = document.getElementById('hand-cursor');
        const statusDiv = document.getElementById('status');
        
        let isHandDetected = false;
        
        // Coordinates for logic (0.0 to 1.0)
        let inputX = 0.5, inputY = 0.5;
        
        // Hand Smoothing
        let handTargetX = 0.5, handTargetY = 0.5;
        let handSmoothX = 0.5, handSmoothY = 0.5;

        // MOUSE LISTENER (Fallback)
        window.addEventListener('mousemove', (event) => {
            if (!isHandDetected) {
                // Map mouse pixels to 0.0 - 1.0
                inputX = event.clientX / window.innerWidth;
                inputY = event.clientY / window.innerHeight;
            }
        });

        // HAND LISTENER
        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const landmarks = results.multiHandLandmarks[0];
                const indexFinger = landmarks[8];

                handTargetX = 1.0 - indexFinger.x; // Mirror flip
                handTargetY = indexFinger.y;
                
                // Show Hand Cursor
                cursorDiv.style.display = 'block';
                statusDiv.innerHTML = "üñê <b>HAND MODE</b><br>Move hand to edges";
                statusDiv.style.color = "#00ff00";

            } else {
                isHandDetected = false;
                
                // Hide Hand Cursor (Use system mouse)
                cursorDiv.style.display = 'none';
                statusDiv.innerHTML = "üñ± <b>MOUSE MODE</b><br>Move mouse to edges";
                statusDiv.style.color = "#00ffff";
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        // =========================================
        // 3. NAVIGATION LOGIC
        // =========================================

        function updateNavigation() {
            // If Hand Mode, apply smoothing
            if (isHandDetected) {
                handSmoothX += (handTargetX - handSmoothX) * CONFIG.smoothing;
                handSmoothY += (handTargetY - handSmoothY) * CONFIG.smoothing;
                
                // Update Red Cursor
                cursorDiv.style.left = `${handSmoothX * 100}%`;
                cursorDiv.style.top = `${handSmoothY * 100}%`;
                
                // Set input to smoothed values
                inputX = handSmoothX;
                inputY = handSmoothY;
            }

            // EDGE DETECTION LOGIC (Applied to both Hand and Mouse)
            const T = CONFIG.edgeThreshold;
            let rotating = false;

            // Horizontal Rotation
            if (inputX < T) {
                // Left Edge: Calculate speed based on how deep we are in the zone
                // (T - inputX) / T gives a value from 0 to 1
                const intensity = (T - inputX) / T; 
                rotateScene(-1 * intensity * CONFIG.maxSpeed);
                rotating = true;
                statusDiv.innerHTML = isHandDetected ? "üñê LEFT <<<" : "üñ± LEFT <<<";
            } 
            else if (inputX > (1 - T)) {
                // Right Edge
                const intensity = (inputX - (1 - T)) / T;
                rotateScene(1 * intensity * CONFIG.maxSpeed);
                rotating = true;
                statusDiv.innerHTML = isHandDetected ? "üñê RIGHT >>>" : "üñ± RIGHT >>>";
            }

            // Vertical Movement (Pitch)
            if (inputY < T) {
                camera.position.y += 0.5 * (isHandDetected ? 2 : 1);
            } else if (inputY > (1 - T)) {
                camera.position.y -= 0.5 * (isHandDetected ? 2 : 1);
            }

            // Reset AutoRotate if interacting
            if (rotating) {
                mouseControls.autoRotate = false;
            } else {
                // If in center, maybe resume auto rotate or stay still
                // mouseControls.autoRotate = true; 
                if(isHandDetected) statusDiv.innerHTML = "üñê HAND MODE";
                else statusDiv.innerHTML = "üñ± MOUSE MODE";
            }
        }

        // Helper to rotate scene smoothly
        function rotateScene(speedVal) {
            // We rotate the camera around the center (0,0,0)
            const x = camera.position.x;
            const z = camera.position.z;
            
            // Simple rotation matrix around Y axis
            const angle = speedVal * 0.02; // Base speed factor
            
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            
            camera.position.x = x * cos - z * sin;
            camera.position.z = x * sin + z * cos;
            
            camera.lookAt(0, 0, 0);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            planets.forEach(p => {
                p.group.rotation.y += p.speed;
                p.mesh.rotation.y += 0.01;
            });
            sun.rotation.y += 0.002;
            stars.rotation.y -= 0.0002;

            updateNavigation();

            mouseControls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        // 4. Start Logic
        const btn = document.getElementById('start-btn');
        btn.addEventListener('click', async () => {
            btn.innerText = "Initializing...";
            
            try {
                // Flexible camera resolution for better compatibility
                const cameraUtils = new Camera(videoElement, {
                    onFrame: async () => { await hands.send({image: videoElement}); }
                });
                await cameraUtils.start();
                
                btn.style.display = 'none';
                videoElement.style.display = 'block';
                statusDiv.innerText = "System Ready";
                
                animate();
                
            } catch (error) {
                console.error(error);
                alert("Camera Access Error. Please check permissions.");
                btn.innerText = "Retry";
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
